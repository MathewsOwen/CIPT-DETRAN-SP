<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>DETRAN 3D - Estética Premium</title>
    <style> 
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', sans-serif; } 
        #ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; }
        .timer { font-size: 40px; font-weight: bold; color: #333; background: white; padding: 10px 40px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); border-bottom: 5px solid #ddd; }
    </style>
</head>
<body>
    <div id="ui"><div class="timer" id="timerDisplay">00:00.00</div></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true; // Habilita sombras
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // LUZES ESTILO JOGO
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(10, 20, 10);
        sun.castShadow = true;
        scene.add(sun);

        // CENÁRIO: GRAMA E ASFALTO
        const floor = new THREE.Group();
        const grass = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshPhongMaterial({color: 0x7cfc00}));
        grass.rotation.x = -Math.PI / 2;
        grass.receiveShadow = true;
        floor.add(grass);

        const road = new THREE.Mesh(new THREE.PlaneGeometry(16, 200), new THREE.MeshPhongMaterial({color: 0x333333}));
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.01;
        road.receiveShadow = true;
        floor.add(road);

        // FAIXAS CENTRAIS
        for(let i = -100; i < 100; i+=8) {
            const stripe = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 4), new THREE.MeshPhongMaterial({color: 0xFFFF00}));
            stripe.rotation.x = -Math.PI / 2; stripe.position.set(0, 0.02, i);
            floor.add(stripe);
        }
        scene.add(floor);

        // CRIANDO UM CARRO MAIS REALISTA (Agrupando peças)
        const car = new THREE.Group();
        
        // Base do carro (Corpo baixo)
        const mainBody = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.6, 4.5), new THREE.MeshPhongMaterial({color: 0xd32f2f}));
        mainBody.position.y = 0.5;
        mainBody.castShadow = true;
        car.add(mainBody);

        // Cabine (Parte de cima)
        const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.6, 2), new THREE.MeshPhongMaterial({color: 0x222222}));
        cabin.position.set(0, 1.1, -0.2);
        car.add(cabin);

        // Rodas
        const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 32);
        const wheelMat = new THREE.MeshPhongMaterial({color: 0x111111});
        const wheelPos = [[1.1, 0.4, 1.2], [-1.1, 0.4, 1.2], [1.1, 0.4, -1.2], [-1.1, 0.4, -1.2]];
        wheelPos.forEach(p => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(p[0], p[1], p[2]);
            car.add(w);
        });

        scene.add(car);

        // CONES ESTILIZADOS
        function criarCone(x, z) {
            const cone = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.8), new THREE.MeshPhongMaterial({color: 0x333}));
            const body = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1, 16), new THREE.MeshPhongMaterial({color: 0xFF4500}));
            body.position.y = 0.5;
            cone.add(base, body);
            cone.position.set(x, 0, z);
            scene.add(cone);
        }
        [-6, 6].forEach(x => { for(let z=-20; z<=20; z+=10) criarCone(x, z); });

        // MOVIMENTAÇÃO E CRONÔMETRO
        let startTime, running = false;
        const keys = {};
        window.addEventListener('keydown', e => { 
            keys[e.code] = true; 
            if(!running && e.code.includes('Arrow')) { running = true; startTime = Date.now(); }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        function animate() {
            requestAnimationFrame(animate);
            if(keys['ArrowUp']) car.translateZ(-0.15);
            if(keys['ArrowDown']) car.translateZ(0.12);
            if(keys['ArrowLeft']) car.rotation.y += 0.035;
            if(keys['ArrowRight']) car.rotation.y -= 0.035;

            if(running) {
                const d = new Date(Date.now() - startTime);
                document.getElementById('timerDisplay').innerText = d.toISOString().substr(14, 8);
            }

            const offset = new THREE.Vector3(0, 5, 10).applyMatrix4(car.matrixWorld);
            camera.position.lerp(offset, 0.1);
            camera.lookAt(car.position);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
